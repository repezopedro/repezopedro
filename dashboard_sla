import streamlit as st
import pandas as pd
import plotly.express as px
from datetime import timedelta
import numpy as np
import os
import time

# ==============================================================================
# 1. Configurações Iniciais e Simulação de Dados (para teste)
# ==============================================================================

# Configuração da página do Streamlit
st.set_page_config(
    page_title="Dashboard de Performance de SLA de Pedidos | Supply Chain",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Paleta de cores inspirada em "Bioxxi" (Ciano/Verde e Cinza Profissional)
COLOR_PRIMARY = "#0065D1"  # Azul Ciano
COLOR_SECONDARY = '#3CB371' # Verde Claro
COLOR_TEXT = '#2F4F4F'     # Cinza Escuro (Slate Gray)

# Função auxiliar para simular o cálculo de dias úteis (Simplificado)
def add_business_days(date, days_to_add):
    """Calcula a data 'X' dias úteis após a data inicial (excluindo Sáb/Dom)."""
    if pd.isna(date):
        return pd.NaT
    
    current_date = date
    while days_to_add > 0:
        current_date += timedelta(days=1)
        # 0=Segunda, 6=Domingo
        if current_date.weekday() < 5:  # Se não for Sábado (5) ou Domingo (6)
            days_to_add -= 1
    return current_date

# Função para carregar e preparar os dados (AGORA COM NORMALIZAÇÃO DE COLUNAS)
@st.cache_data(show_spinner="Carregando e processando dados de SLA...")
def load_data(file_path):
    """Carrega, filtra e prepara os dados da planilha Excel."""
    try:
        df = pd.read_excel(file_path, sheet_name='VIEW_PEDIDOS_SLA')
    except FileNotFoundError:
        st.error(f"Arquivo não encontrado em: {file_path}. Por favor, verifique o caminho.")
        return None
    except ValueError:
        st.error("Planilha 'VIEW_PEDIDOS_SLA' não encontrada no arquivo Excel.")
        return None
    except Exception as e:
        st.error(f"Erro ao carregar os dados: {e}")
        return None

    # 1. NORMALIZAÇÃO DE NOMES DE COLUNAS: MAIÚSCULAS e REMOVER ESPAÇOS
    # Isso resolve o KeyError
    df.columns = df.columns.str.strip().str.upper()

    # Variável de coluna crítica (usada em todos os cálculos CMEXX)
    COLUMN_CMEXX = 'DATA_APROVACAO_CMEXX'
    if COLUMN_CMEXX not in df.columns:
        # Se a coluna não for encontrada após a normalização, gera erro para diagnóstico.
        st.error(f"❌ ERRO CRÍTICO: Coluna '{COLUMN_CMEXX}' não encontrada.")
        st.warning(f"Nomes de Colunas Encontradas: {list(df.columns)}")
        return None

    # Conversão de Tipos de Dados Obrigatória (Usando nomes normalizados)
    date_cols = ['DTCRIACAO', 'DATACOMPETENCIA', 'DTAPROVACAO', 'DTAPROVACAOGERENCIA',
                 'DTIMPORTACAO', 'DATAEMISSAO', 'DTCONFIRMACAO', 'DTCONFIRMACAOSUPRIMENTOS',
                 COLUMN_CMEXX, 'DATA_PREVISTA_ENTREGA']
    
    # Colunas de ID e Categoria (também normalizadas)
    id_cols = ['IDSOLICITACAO', 'NUMEROMOV', 'IDMOV', 'CENTRO_CUSTO', 'PEDIDO_EXTRA', 'STATUS_MOVIMENTO']
    
    # Converte Datas
    for col in date_cols:
        if col in df.columns:
            df[col] = pd.to_datetime(df[col], errors='coerce')
            
    # Converte IDs para String (para garantir 'nunique' correto em Pandas)
    for col in id_cols:
         if col in df.columns:
            df[col] = df[col].astype(str)

    # Exclusão de Pedidos Extras (Requisito)
    df = df[df['PEDIDO_EXTRA'] != 'S'].copy()

    # Criação de colunas auxiliares
    df['AnoCriacao'] = df['DTCRIACAO'].dt.year
    df['MesAnoCompetencia'] = df['DATACOMPETENCIA'].dt.to_period('M')

    # KPI 3: Adesão à Criação Mensal (Corte Dia 20)
    df['DiaCriacao'] = df['DTCRIACAO'].dt.day
    df['DentroPrazoCorte'] = (df['DiaCriacao'] <= 20)

    # KPI 4: Cálculo de SLA CMEXX (2 Dias Úteis após DTCRIACAO)
    df['SLA_CMEXX_Lim'] = df.apply(
        lambda row: add_business_days(row['DTCRIACAO'], 2),
        axis=1
    )
    df['SLA_CMEXX_Cumprido'] = df[COLUMN_CMEXX] <= df['SLA_CMEXX_Lim']
    df['SLA_CMEXX_Cumprido'] = df['SLA_CMEXX_Cumprido'].fillna(False)

    # KPI 5: Cálculo de SLA Importação (2 Dias Úteis após DATA_APROVACAO_CMEXX)
    df['SLA_IMP_Lim'] = df.apply(
        lambda row: add_business_days(row[COLUMN_CMEXX], 2),
        axis=1
    )
    df['SLA_IMP_Cumprido'] = df['DTIMPORTACAO'] <= df['SLA_IMP_Lim']
    df['SLA_IMP_Cumprido'] = df['SLA_IMP_Cumprido'].fillna(False)

    return df

# Função para gerar um DataFrame de exemplo caso o arquivo não exista
def generate_sample_data(num_records: int = 120) -> pd.DataFrame:
    """Gera um DataFrame de exemplo compatível com o processamento do dashboard.

    A função cria colunas com os nomes normalizados utilizados no script
    (ex.: 'DTCRIACAO', 'DATACOMPETENCIA', 'IDSOLICITACAO', 'NUMEROMOV', etc.)
    e também preenche as colunas derivadas esperadas pelo restante do código.
    """
    import random

    # Período de criação: últimos 6 meses
    end = pd.Timestamp.today().normalize()
    start = (end - pd.offsets.MonthBegin(6)).normalize()

    rng = pd.date_range(start=start, end=end, periods=num_records)

    data = {
        'IDSOLICITACAO': [f'SOL-{i//3:04d}' for i in range(num_records)],
        'NUMEROMOV': [f'NMV-{i:05d}' for i in range(num_records)],
        'IDMOV': [f'IMV-{i:06d}' for i in range(num_records)],
        'CENTRO_CUSTO': [random.choice(['CC100','CC200','CC300']) for _ in range(num_records)],
        'PEDIDO_EXTRA': [random.choice(['N','N','N','S']) for _ in range(num_records)],
        'STATUS_MOVIMENTO': [random.choice(['A','B','C']) for _ in range(num_records)],
        'DTCRIACAO': rng,
        # Competência: use o primeiro dia do mês de criação
        'DATACOMPETENCIA': [pd.Timestamp(d.year, d.month, 1) for d in rng],
        'DATAEMISSAO': rng - pd.to_timedelta(np.random.randint(0, 5, size=num_records), unit='d'),
        'DATA_PREVISTA_ENTREGA': rng + pd.to_timedelta(np.random.randint(3, 30, size=num_records), unit='d'),
        # Simula aprovação CMEXX em 0-4 dias úteis após criação
        'DATA_APROVACAO_CMEXX': [add_business_days(d, int(random.choice([0,1,1,2,3,4]))) for d in rng],
        # Simula data de importacao 0-6 dias úteis após aprovação
        'DTIMPORTACAO': [],
        # Confirmação de suprimentos (pode ser NaT para alguns)
        'DTCONFIRMACAOSUPRIMENTOS': [] ,
        # Total (valor) para tabela
        'TOTAL': np.round(np.random.uniform(100.0, 5000.0, size=num_records), 2)
    }

    # Preenche DTIMPORTACAO e DTCONFIRMACAOSUPRIMENTOS com base nas aprovações
    for aprov in data['DATA_APROVACAO_CMEXX']:
        # 70% chance de ter importação em 0-4 dias úteis, senão NaT
        if pd.isna(aprov) or random.random() < 0.15:
            data['DTIMPORTACAO'].append(pd.NaT)
        else:
            data['DTIMPORTACAO'].append(add_business_days(aprov, int(random.choice([0,1,1,2,3]))))

    for cri in data['DTCRIACAO']:
        # 60% chance de confirmação de suprimentos ocorrer antes do fim do mês de competencia
        if random.random() < 0.6:
            data['DTCONFIRMACAOSUPRIMENTOS'].append(cri + pd.to_timedelta(np.random.randint(1, 25), unit='d'))
        else:
            data['DTCONFIRMACAOSUPRIMENTOS'].append(pd.NaT)

    df = pd.DataFrame(data)

    # Normaliza colunas (simula o comportamento do load_data)
    df.columns = df.columns.str.strip().str.upper()

    # Garante tipos
    df['DTCRIACAO'] = pd.to_datetime(df['DTCRIACAO'], errors='coerce')
    df['DATACOMPETENCIA'] = pd.to_datetime(df['DATACOMPETENCIA'], errors='coerce')
    df['DATA_APROVACAO_CMEXX'] = pd.to_datetime(df['DATA_APROVACAO_CMEXX'], errors='coerce')
    df['DTIMPORTACAO'] = pd.to_datetime(df['DTIMPORTACAO'], errors='coerce')
    df['DATA_PREVISTA_ENTREGA'] = pd.to_datetime(df['DATA_PREVISTA_ENTREGA'], errors='coerce')

    # Exclui pedidos extras (mantém consistência com load_data flows)
    df = df[df['PEDIDO_EXTRA'] != 'S'].copy()

    # Colunas derivadas
    df['AnoCriacao'] = df['DTCRIACAO'].dt.year
    df['MesAnoCompetencia'] = df['DATACOMPETENCIA'].dt.to_period('M')
    df['DiaCriacao'] = df['DTCRIACAO'].dt.day
    df['DENTROPRAZOCORTE'] = (df['DiaCriacao'] <= 20)

    # SLA CMEXX limite e cumprimento (nomes em MAIÚSCULAS)
    df['SLA_CMEXX_LIM'] = df['DTCRIACAO'].apply(lambda d: add_business_days(d, 2) if not pd.isna(d) else pd.NaT)
    df['SLA_CMEXX_CUMPRIDO'] = (df['DATA_APROVACAO_CMEXX'] <= df['SLA_CMEXX_LIM']).fillna(False)

    # SLA importação (nomes em MAIÚSCULAS)
    df['SLA_IMP_LIM'] = df['DATA_APROVACAO_CMEXX'].apply(lambda d: add_business_days(d, 2) if not pd.isna(d) else pd.NaT)
    df['SLA_IMP_CUMPRIDO'] = (df['DTIMPORTACAO'] <= df['SLA_IMP_LIM']).fillna(False)

    # Ajuste de nomes para compatibilidade com restante do script
    # O restante do script cria/espera colunas com case mista (ex: 'SLA_CMEXX_Lim')
    # Para evitar KeyErrors quando usamos os dados de simulação, criamos aliases.
    df['SLA_CMEXX_Lim'] = df['SLA_CMEXX_LIM']
    df['SLA_CMEXX_Cumprido'] = df['SLA_CMEXX_CUMPRIDO']
    df['SLA_IMP_Lim'] = df['SLA_IMP_LIM']
    df['SLA_IMP_Cumprido'] = df['SLA_IMP_CUMPRIDO']

    # Ajuste de nome para 'DentroPrazoCorte' com capitalização esperada
    df = df.rename(columns={'DENTROPRAZOCORTE': 'DentroPrazoCorte'})

    return df

# ==============================================================================
# 2. Funções de Cálculo das Métricas (KPIs)
# ==============================================================================

def calculate_kpi_adesao_corte(df):
    """KPI 3: % de Pedidos Criados no Prazo de Corte (Dia 20) - Base IdSolicitacao."""
    if df.empty:
        return 0.0

    # Usa IDSOLICITACAO (Normalizado)
    grouped = df.groupby('IDSOLICITACAO').first().reset_index()

    total_pedidos = grouped['IDSOLICITACAO'].nunique()
    pedidos_no_prazo = grouped[grouped['DentroPrazoCorte'] == True]['IDSOLICITACAO'].nunique()

    return (pedidos_no_prazo / total_pedidos) if total_pedidos > 0 else 0.0

def calculate_kpi_sla_cmexx(df):
    """KPI 4: % de Aprovações CMEXX no Prazo (2 Dias Úteis) - Base IdSolicitacao."""
    if df.empty:
        return 0.0

    grouped = df.groupby('IDSOLICITACAO').first().reset_index()

    total_pedidos = grouped['IDSOLICITACAO'].nunique()
    pedidos_no_prazo = grouped[grouped['SLA_CMEXX_Cumprido'] == True]['IDSOLICITACAO'].nunique()

    return (pedidos_no_prazo / total_pedidos) if total_pedidos > 0 else 0.0

def calculate_kpi_sla_importacao(df):
    """KPI 5: % de Importações no Prazo (2 Dias Úteis) - Base IdSolicitacao."""
    if df.empty:
        return 0.0

    grouped = df.groupby('IDSOLICITACAO').first().reset_index()

    total_pedidos = grouped['IDSOLICITACAO'].nunique()
    pedidos_no_prazo = grouped[grouped['SLA_IMP_Cumprido'] == True]['IDSOLICITACAO'].nunique()

    return (pedidos_no_prazo / total_pedidos) if total_pedidos > 0 else 0.0

def plot_kpi_eficiencia_entrega(df):
    """KPI 2: % de Pedidos Entregues no Prazo de Competência (Gráfico de Linha/Barra) - Base NUMEROMOV."""
    if df.empty:
        st.info("Nenhum dado para o período selecionado.")
        return

    df_unique = df.groupby('NUMEROMOV').first().reset_index()
    df_unique['MesAnoCompetencia_str'] = df_unique['DATACOMPETENCIA'].dt.to_period('M').astype(str)
    
    df_unique['EntregueNoPrazo'] = df_unique['DTCONFIRMACAOSUPRIMENTOS'] <= df_unique['DATACOMPETENCIA']

    grouped_final = df_unique.groupby('MesAnoCompetencia_str').agg(
        Total_Pedidos=('NUMEROMOV', 'nunique'),
        Pedidos_Entregues=('EntregueNoPrazo', 'sum')
    ).reset_index().sort_values('MesAnoCompetencia_str')

    grouped_final['Percentual_SLA'] = (grouped_final['Pedidos_Entregues'] / grouped_final['Total_Pedidos']) * 100
    grouped_final = grouped_final.fillna(0)

    fig = px.line(
        grouped_final,
        x='MesAnoCompetencia_str',
        y='Percentual_SLA',
        title='% de Pedidos Entregues no Prazo de Competência',
        markers=True,
        template="plotly_white",
        color_discrete_sequence=[COLOR_PRIMARY]
    )
    fig.update_traces(hovertemplate='%{y:.2f}%<extra></extra>')
    fig.update_yaxes(title="Percentual (%)", tickformat=".0f", range=[0, 100])
    fig.update_xaxes(title="Mês/Ano de Competência")
    st.plotly_chart(fig, use_container_width=True)


# --- NOVAS FUNÇÕES DE DETALHE ---

def calculate_adesao_by_month(df):
    """Calcula o % de Pedidos Criados no Prazo de Corte (Dia 20) MÊS A MÊS."""
    if df.empty:
        return pd.DataFrame()

    df_unique = df.groupby('IDSOLICITACAO').first().reset_index()
    df_unique['MesAnoCriacao_str'] = df_unique['DTCRIACAO'].dt.to_period('M').astype(str)

    grouped = df_unique.groupby('MesAnoCriacao_str').agg(
        Total_Pedidos=('IDSOLICITACAO', 'nunique'),
        Pedidos_No_Prazo=('DentroPrazoCorte', 'sum')
    ).reset_index().sort_values('MesAnoCriacao_str')
    
    grouped['Percentual_Adesao'] = (grouped['Pedidos_No_Prazo'] / grouped['Total_Pedidos']) * 100
    grouped = grouped.fillna(0)

    return grouped

def plot_adesao_by_month(df_monthly):
    """Gera o gráfico de linha para Adesão Mensal ao Prazo de Corte."""
    if df_monthly.empty:
        st.warning("Nenhum dado mensal para plotar.")
        return

    fig = px.line(
        df_monthly,
        x='MesAnoCriacao_str',
        y='Percentual_Adesao',
        title='Adesão Mensal ao Prazo de Corte (Dia 20)',
        markers=True,
        template="plotly_white",
        color_discrete_sequence=[COLOR_SECONDARY]
    )
    fig.update_traces(hovertemplate='**Mês:** %{x}<br>**Adesão:** %{y:.2f}%<extra></extra>')
    fig.update_yaxes(title="Percentual (%)", tickformat=".0f", range=[0, 100])
    fig.update_xaxes(title="Mês/Ano de Criação")
    st.plotly_chart(fig, use_container_width=True)

# ==============================================================================
# 3. Layout e Execução do Dashboard
# ==============================================================================

def display_kpi_card(title, value, help_text=None):
    """Exibe um Cartão de KPI formatado no Streamlit."""
    if help_text:
        st.markdown(f"<span style='font-size: 1em;'>**{title}**</span> <sup title='{help_text}' style='font-size: 0.7em;'>ⓘ</sup>", unsafe_allow_html=True)
    else:
        st.markdown(f"**{title}**")
    
    st.markdown(f"<p style='font-size: 2em; color: {COLOR_TEXT}; margin-bottom: 0px;'>{value:.2%}</p>", unsafe_allow_html=True)
    st.markdown("---")


def main_dashboard():
    """Função principal para montar o dashboard."""
    
    # Inicializa o estado da sessão para controle de tela
    if 'page' not in st.session_state:
        st.session_state.page = 'main'
    
    # DEFINIÇÃO DO CAMINHO DO ARQUIVO (ATUALIZADO)
    file_path = r'C:\Users\pedro.muniz\Documents\pythonlocal\BIOXXI\INDICADORESCMEXXFAB\CMEXXFAB_SQL.xlsx'
    
    # O Streamlit usa o cache, então a carga é rápida se o arquivo não mudar.
    if os.path.exists(file_path):
        df_base = load_data(file_path)
    else:
        st.warning(f"Arquivo não encontrado no caminho: `{file_path}`. Usando dados de simulação gerados localmente.")
        # Gera dados de exemplo para permitir testes locais sem o arquivo Excel.
        df_base = generate_sample_data()

    if df_base is None or df_base.empty:
        # Se o load_data falhar (ex: coluna não encontrada após normalização), ele retorna None
        st.stop()
    
    # --- Sidebar de Filtros (KPI 1) --- (Mantido)
    st.sidebar.header("Filtros de Análise")
    all_years = sorted(df_base['AnoCriacao'].dropna().unique().astype(int).tolist(), reverse=True)
    
    if not all_years:
        st.sidebar.warning("Nenhum ano de criação encontrado nos dados válidos.")
        st.stop()

    selected_years = st.sidebar.multiselect(
        "Selecione o(s) Ano(s) de Criação:",
        options=all_years,
        default=all_years[:2] if len(all_years) > 1 else all_years
    )

    if not selected_years:
        st.sidebar.warning("Selecione pelo menos um ano.")
        st.stop()

    df_filtered = df_base[df_base['AnoCriacao'].isin(selected_years)].copy() # Use copy() após filtragem
    
    all_cc = sorted(df_base['CENTRO_CUSTO'].dropna().unique().tolist())
    selected_cc = st.sidebar.multiselect(
        "Filtro por Centro de Custo:",
        options=all_cc,
        default=[] 
    )
    
    if selected_cc:
        df_filtered = df_filtered[df_filtered['CENTRO_CUSTO'].isin(selected_cc)]
        
    st.sidebar.info(f"Total de Pedidos na Visão: **{df_filtered['IDSOLICITACAO'].nunique():,}**")
    
    # ------------------------------------
    
    # Lógica de Navegação
    if st.session_state.page == 'main':
        st.title("Performance Entrega de Insumos")
        st.markdown(f"<span style='color:{COLOR_TEXT}; font-size: 0.9em;'>Análise de Eficiência de Aprovação, Importação e Entrega.</span>", unsafe_allow_html=True)
        st.markdown("---")
        
        # 1. Linha dos Cartões de KPI
        st.subheader("Indicadores Chave de SLA (Período Filtrado)")
        col_kpi1, col_kpi2, col_kpi3, col_kpi_total = st.columns(4)

        # KPI 3: Adesão à Criação Mensal (Corte Dia 20) - COM BOTÃO DE DETALHE
        kpi_adesao = calculate_kpi_adesao_corte(df_filtered)
        with col_kpi1:
            display_kpi_card(
                "Adesão ao Prazo de Criação | Operações",
                kpi_adesao,
                help_text="Porcentagem de Pedidos (IdSolicitacao) criados até o dia 20 do mês de criação."
            )
            # BOTÃO PARA DETALHE
            if st.button('📈 Ver Tendência Mensal', key='btn_detalhe_adesao', use_container_width=True):
                st.session_state.page = 'detalhe_adesao'
                st.rerun()

        # KPI 4: SLA de Aprovação CMEXX (2 Dias Úteis)
        kpi_cmexx = calculate_kpi_sla_cmexx(df_filtered)
        with col_kpi2:
            display_kpi_card(
                "SLA Aprovação CMEXX",
                kpi_cmexx,
                help_text="Porcentagem de Pedidos (IdSolicitacao) com aprovação CMEXX em até 2 dias úteis da criação."
            )

        # KPI 5: SLA de Importação (2 Dias Úteis)
        kpi_importacao = calculate_kpi_sla_importacao(df_filtered)
        with col_kpi3:
            display_kpi_card(
                "SLA de Importação",
                kpi_importacao,
                help_text="Porcentagem de Pedidos (IdSolicitacao) com Importação em até 2 dias úteis da aprovação CMEXX."
            )
            
        # Cartão de Total de Pedidos
        with col_kpi_total:
            st.markdown(f"**Total de Pedidos**")
            st.markdown(f"<p style='font-size: 2em; color: {COLOR_TEXT}; margin-bottom: 0px;'>{df_filtered['IDSOLICITACAO'].nunique():,}</p>", unsafe_allow_html=True)
            st.markdown("---")

        # 2. Gráfico de Tendência (KPI 2)
        st.subheader("Tendência Mensal de Eficiência de Entrega")
        plot_kpi_eficiencia_entrega(df_filtered)
        st.markdown("---")
        
        # 3. Tabela de Acompanhamento (KPI 6)
        st.subheader("Acompanhamento Detalhado de Previsão de Entrega")
        
        cols_table = ['IDMOV', 'IDSOLICITACAO', 'NUMEROMOV', 'CENTRO_CUSTO', 'DATAEMISSAO',
                      'DATA_PREVISTA_ENTREGA', 'STATUS_MOVIMENTO', 'DTCRIACAO', 'TOTAL']
        
        cols_to_display = [col for col in cols_table if col in df_filtered.columns]
        
        df_table = df_filtered[cols_to_display].sort_values('DTCRIACAO', ascending=False).head(500)
        
        st.dataframe(
            df_table,
            use_container_width=True,
            hide_index=True,
            column_config={
                "TOTAL": st.column_config.NumberColumn("Total (R$)", format="R$ %.2f"),
                "DTCRIACAO": st.column_config.DateColumn("Criação", format="DD/MM/YYYY"),
                "DATAEMISSAO": st.column_config.DateColumn("Emissão", format="DD/MM/YYYY"),
                "DATA_PREVISTA_ENTREGA": st.column_config.DateColumn("Prev. Entrega", format="DD/MM/YYYY"),
            }
        )

        st.markdown("***")
        st.markdown("*Nota do Arquiteto:* Este é o *MVP*. O próximo passo seria a inclusão de uma tabela de feriados para um cálculo de dias úteis 100% preciso.")

    # --- Tela de Detalhe do KPI 3 ---
    elif st.session_state.page == 'detalhe_adesao':
        st.title("🔎 Detalhe: Adesão Mensal ao Prazo para Aprovação (Até oDia 20)")
        
        # BOTÃO DE RETORNO
        if st.button('⬅️ Voltar ao Dashboard Principal', key='btn_voltar', type='primary'):
            st.session_state.page = 'main'
            st.rerun()

        st.markdown("---")
        
        # Cálculo e Plotagem do Detalhe
        df_mensal = calculate_adesao_by_month(df_filtered)
        
        if not df_mensal.empty:
            plot_adesao_by_month(df_mensal)
            
            st.subheader("Dados de Suporte")
            st.dataframe(df_mensal, use_container_width=True, hide_index=True)
        else:
            st.info("Nenhum dado encontrado para o cálculo mensal no período filtrado.")

if __name__ == '__main__':
    main_dashboard()
